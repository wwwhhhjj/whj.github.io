<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://whj.github.io/atom.xml" rel="self"/>
  
  <link href="https://whj.github.io/"/>
  <updated>2024-12-02T08:51:49.566Z</updated>
  <id>https://whj.github.io/</id>
  
  <author>
    <name>whj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Typora图床搭建</title>
    <link href="https://whj.github.io/2024/12/02/Typora%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/"/>
    <id>https://whj.github.io/2024/12/02/Typora%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/</id>
    <published>2024-12-02T08:28:30.399Z</published>
    <updated>2024-12-02T08:51:49.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、仓库的建立"><a href="#一、仓库的建立" class="headerlink" title="一、仓库的建立"></a>一、仓库的建立</h2><p>先在github创建一个新的仓库，专门用于托管图床文件</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A/image-20241202114129497.png" alt="image-20241202114129497"></p><p>点击new repository建立新仓库，切记要设置成public否则其他人访问不到</p><p>创建好后，按需通过git 命令创建一个存储图片的文件夹</p><h2 id="二、配置工具"><a href="#二、配置工具" class="headerlink" title="二、配置工具"></a>二、配置工具</h2><h3 id="1-下载一个PicGo工具"><a href="#1-下载一个PicGo工具" class="headerlink" title="1.下载一个PicGo工具"></a>1.下载一个PicGo工具</h3><p>在github上就有，一个开源项目</p><p>下载好后打开，配置github的相关设置</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A/image-20241202114516599.png" alt="image-20241202114516599"></p><p>仓库名即为刚刚创建的仓库的连接，只需要后面部分的就行，前面的https域名不需要</p><p>然后设定分支名为main默认，如果你的分支为master就设置为master</p><h3 id="2-设置token令牌"><a href="#2-设置token令牌" class="headerlink" title="2.设置token令牌"></a>2.设置token令牌</h3><p>打开github设置，找到最下面的开发者选项</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A/image-20241202114822352.png" alt="image-20241202114822352"></p><p>点进去后可以看到令牌，我们随便选一个 Generate new token</p><p>名字随便填一个，令牌时间我选无期限</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A/image-20241202115111448.png" alt="image-20241202115111448"></p><p>然后在repository access选项选择第三个选项，填入你刚刚创建的图床仓库</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A/image-20241202115231210.png" alt="image-20241202115231210"></p><p>下面的权限将第一栏打开，找到contes将其设定为可读写</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A/image-20241202115338209.png" alt="image-20241202115338209"></p><p>然后划到下面生成令牌</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A/image-20241202115401825.png" alt="image-20241202115401825"></p><p>生成之后复制令牌，我这里复制过了所以不显示</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A/image-20241202115439206.png" alt="image-20241202115439206"></p><p>将复制的令牌粘贴到PicGo配置里面的token选项，存储路径可以选择你在仓库里创建的文件夹，相当于你在仓库里新建了一个房间，这个房间专门共你存放照片</p><h3 id="3-github插件导入"><a href="#3-github插件导入" class="headerlink" title="3.github插件导入"></a>3.github插件导入</h3><p>打开PicGo里面的插件设置，点开上面的购物袋图标</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A/image-20241202115727941.png" alt="image-20241202115727941"></p><p>下载这个插件并解压<img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A/image-20241202115820400.png" alt="image-20241202115820400"></p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A/image-20241202115838790.png" alt="image-20241202115838790"></p><p>然后从本地的解压路径导入即可</p><h2 id="三、Typora的配置"><a href="#三、Typora的配置" class="headerlink" title="三、Typora的配置"></a>三、Typora的配置</h2><p>左上角文件点开偏好设置</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A/image-20241202120959186.png" alt="image-20241202120959186"></p><p>在插入图片时选中上传图片，然后配置下面的选项</p><p>选择PicGo（app）,然后导入你APP的路径，在点击左边的验证图片上传，就成功了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、仓库的建立&quot;&gt;&lt;a href=&quot;#一、仓库的建立&quot; class=&quot;headerlink&quot; title=&quot;一、仓库的建立&quot;&gt;&lt;/a&gt;一、仓库的建立&lt;/h2&gt;&lt;p&gt;先在github创建一个新的仓库，专门用于托管图床文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RT-thread学习报告</title>
    <link href="https://whj.github.io/2024/12/02/RT_thread%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>https://whj.github.io/2024/12/02/RT_thread%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</id>
    <published>2024-12-02T08:28:30.394Z</published>
    <updated>2024-12-02T08:51:31.005Z</updated>
    
    <content type="html"><![CDATA[<p>RT-threadq嵌入式实时操作系统</p><p>物联网操作系统是指以操作系统内核（可以是 RTOS、Linux 等）为基础，包括如文件系统、图形库等较为完整的中间件组件，具备低功耗、安全、通信协议支持和云端连接能力的软件平台</p><h1 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>邮箱（MailBox）是一种高效的进程间通信（IPC）机制，用于在任务、线程、或中断之间传递消息。邮箱的核心是存储消息地址（通常为指针或整型数据），它不存储消息本体，因此在需要传递大块数据时，邮箱可以显著减少数据复制的开销。</p><h2 id="邮箱的工作机制"><a href="#邮箱的工作机制" class="headerlink" title="邮箱的工作机制"></a>邮箱的工作机制</h2><p>典型的邮箱也称作交换消息，如下图所示，线程或中断服务例程把一封 4 字节长度的邮件发送到邮箱中，而一个或多个线程可以从邮箱中接收这些邮件并进行处理。</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8A07mb_work.png" alt="邮箱工作示意图"></p><p>RT-Thread 操作系统的邮箱用于线程间通信，特点是开销比较低，效率较高。邮箱中的每一封邮件只能容纳固定的 4 字节内容。</p><p>当一个线程向邮箱发送邮件时，如果邮箱没满，将把邮件复制到邮箱中。如果邮箱已经满了，发送线程可以设置超时时间，选择等待挂起或直接返回 - RT_EFULL。如果发送线程选择挂起等待，那么当邮箱中的邮件被收取而空出空间来时，等待挂起的发送线程将被唤醒继续发送。</p><p>当一个线程从邮箱中接收邮件时，如果邮箱是空的，接收线程可以选择是否等待挂起直到收到新的邮件而唤醒，或可以设置超时时间。当达到设置的超时时间，邮箱依然未收到邮件时，这个选择超时等待的线程将被唤醒并返回 - RT_ETIMEOUT。如果邮箱中存在邮件，那么接收线程将复制邮箱中的 4 个字节邮件到接收缓存中。</p><p><strong>消息内容：</strong>邮箱传递的是消息地址（如数据缓冲区地址），而不是实际消息的内容。</p><p><strong>消息队列：</strong>邮箱内部存储消息地址，类似于一个固定容量的队列，支持先进先出（FIFO）或优先级存储。</p><p><strong>同步操作：</strong>支持线程挂起等待消息，也支持非阻塞模式立即返回。</p><h2 id="三、邮箱的管理方式"><a href="#三、邮箱的管理方式" class="headerlink" title="三、邮箱的管理方式"></a>三、邮箱的管理方式</h2><h3 id="邮箱控制块"><a href="#邮箱控制块" class="headerlink" title="邮箱控制块"></a>邮箱控制块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mailbox</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">rt_uint32_t</span>* msg_pool;                <span class="comment">/* 邮箱缓冲区的开始地址 */</span></span><br><span class="line">    <span class="type">rt_uint16_t</span> size;                     <span class="comment">/* 邮箱缓冲区的大小     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">rt_uint16_t</span> entry;                    <span class="comment">/* 邮箱中邮件的数目     */</span></span><br><span class="line">    <span class="type">rt_uint16_t</span> in_offset, out_offset;    <span class="comment">/* 邮箱缓冲的进出指针   */</span></span><br><span class="line">    <span class="type">rt_list_t</span> suspend_sender_thread;      <span class="comment">/* 发送线程的挂起等待队列 */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mailbox</span>* <span class="title">rt_mailbox_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>邮箱控制块是一个结构体，其中含有事件相关的重要参数，在邮箱的功能实现中起重要的作用。邮箱的相关接口如下图所示，对一个邮箱的操作包含：创建 / 初始化邮箱、发送邮件、接收邮件、删除 / 脱离邮箱。</p><p><img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/ipc2/figures/07mb_ops.png" alt="邮箱相关接口"></p><h2 id="四、邮箱的操作"><a href="#四、邮箱的操作" class="headerlink" title="四、邮箱的操作"></a>四、邮箱的操作</h2><h3 id="1-邮箱的创建"><a href="#1-邮箱的创建" class="headerlink" title="1.邮箱的创建"></a>1.邮箱的创建</h3><p><strong>创建（动态）：</strong></p><p>邮箱需要在使用前进行创建，指定容量（能存储的消息地址数量）和调度方式（FIFO 或优先级）。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_mailbox_t</span> mb = rt_mb_create(<span class="string">"mailbox"</span>, <span class="number">10</span>, RT_IPC_FLAG_FIFO);</span><br></pre></td></tr></tbody></table></figure><p>rt_mb_create 参数：</p><ul><li><strong>name:</strong> 邮箱名称。</li><li><strong>size:</strong> 邮箱容量（可存储的消息地址数量）。</li><li><strong>flag:</strong> 调度方式（<code>RT_IPC_FLAG_FIFO</code>或 <code>RT_IPC_FLAG_PRIO</code>）。</li></ul><p> 创建邮箱对象时会先从对象管理器中分配一个邮箱对象，然后给邮箱动态分配一块内存空间用来存放邮件，这块内存的大小等于邮件大小（4 字节）与邮箱容量的   乘积，接着初始化接收邮件数目和发送邮件在邮箱中的偏移量。</p><p><strong>初始化（静态）：</strong></p><p>初始化邮箱跟创建邮箱类似，只是初始化邮箱用于静态邮箱对象的初始化。与创建邮箱不同的是，静态邮箱对象的内存是在系统编译时由编译器分配的，一般放于读写数据段或未初始化数据段中，其余的初始化工作与创建邮箱时相同。函数接口如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_init</span><span class="params">(<span class="type">rt_mailbox_t</span> mb,</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                  <span class="type">void</span>* msgpool,</span></span><br><span class="line"><span class="params">                  <span class="type">rt_size_t</span> size,</span></span><br><span class="line"><span class="params">                  <span class="type">rt_uint8_t</span> flag)</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mb</td><td>邮箱对象的句柄</td></tr><tr><td>name</td><td>邮箱名称</td></tr><tr><td>msgpool</td><td>缓冲区指针</td></tr><tr><td>size</td><td>邮箱容量</td></tr><tr><td>flag</td><td>邮箱标志，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr></tbody></table><p>动态创建的邮箱在最后需要手动删除，并且动态创建的邮箱已经包含了初始化的过程，因此不需要再次手动初始化。</p><h3 id="2-发送邮件"><a href="#2-发送邮件" class="headerlink" title="2.发送邮件"></a>2.发送邮件</h3><p><strong>一般方式：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_send</span> <span class="params">(<span class="type">rt_mailbox_t</span> mb, <span class="type">rt_uint32_t</span> value)</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>等待方式：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_send_wait</span> <span class="params">(<span class="type">rt_mailbox_t</span> mb,</span></span><br><span class="line"><span class="params">                      <span class="type">rt_uint32_t</span> value,</span></span><br><span class="line"><span class="params">                      <span class="type">rt_int32_t</span> timeout)</span>;</span><br></pre></td></tr></tbody></table></figure><p>rt_mb_send_wait() 与 rt_mb_send() 的区别在于有等待时间，如果邮箱已经满了，那么发送线程将根据设定的 timeout 参数等待邮箱中因为收取邮件而空出空间。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。</p><p><strong>紧急邮件：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_urgent</span> <span class="params">(<span class="type">rt_mailbox_t</span> mb, <span class="type">rt_ubase_t</span> value)</span>;</span><br></pre></td></tr></tbody></table></figure><p>紧急邮件的发送过程和发送一般邮件一样，只不过紧急邮件会直接插队到邮箱的队首，这样等待线程就可以第一时间取出紧急邮件并进行处理。</p><h3 id="3-接收邮件"><a href="#3-接收邮件" class="headerlink" title="3.接收邮件"></a>3.接收邮件</h3><p>只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回 RT_EOK 的返回值，否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_recv</span> <span class="params">(<span class="type">rt_mailbox_t</span> mb, <span class="type">rt_uint32_t</span>* value, <span class="type">rt_int32_t</span> timeout)</span>;</span><br></pre></td></tr></tbody></table></figure><p>接收邮件时，接收者需指定接收邮件的邮箱句柄，并指定接收到的邮件存放位置以及最多能够等待的超时时间。如果接收时设定了超时，当指定的时间内依然未收到邮件时，将返回 - RT_ETIMEOUT。</p><h3 id="4-删除邮箱"><a href="#4-删除邮箱" class="headerlink" title="4.删除邮箱"></a>4.删除邮箱</h3><p>当用 <strong>rt_mb_create() 创建的邮箱</strong>不再被使用时，应该删除它来释放相应的系统资源，一旦操作完成，邮箱将被永久性的删除。删除邮箱的函数接口如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_delete</span> <span class="params">(<span class="type">rt_mailbox_t</span> mb)</span>;</span><br></pre></td></tr></tbody></table></figure><p>删除邮箱时，如果有线程被挂起在该邮箱对象上，内核先唤醒挂起在该邮箱上的所有线程（线程返回值是 -RT_ERROR），然后再释放邮箱使用的内存，最后删除邮箱对象。</p><h3 id="5-脱离邮箱"><a href="#5-脱离邮箱" class="headerlink" title="5.脱离邮箱"></a>5.脱离邮箱</h3><p>脱离邮箱将把<strong>静态初始化</strong>的邮箱对象从内核对象管理器中脱离。脱离邮箱使用下面的接口：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_detach</span><span class="params">(<span class="type">rt_mailbox_t</span> mb)</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="一、概述-1"><a href="#一、概述-1" class="headerlink" title="一、概述"></a>一、概述</h2><p>消息队列是另一种常用的线程间通讯方式，是邮箱的扩展。用于在<strong>不同任务或中断之间</strong>传递消息。消息队列不仅可以传递数据，还可以实现任务之间的同步。基于 <strong>RT-Thread</strong> 实时操作系统的实现，消息队列的功能和设计具有高度的灵活性和实时性，适用于多任务环境中任务间的高效通信。</p><h2 id="二、消息队列的基本概念"><a href="#二、消息队列的基本概念" class="headerlink" title="二、消息队列的基本概念"></a>二、消息队列的基本概念</h2><h3 id="1-消息队列的定义"><a href="#1-消息队列的定义" class="headerlink" title="1.消息队列的定义"></a>1.消息队列的定义</h3><p>消息队列是一个先进先出（FIFO）的数据结构。</p><p>消息队列的核心功能是存储消息，并按照任务请求的顺序传递给接收任务。</p><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><p>支持不定长的消息。</p><p>提供非阻塞和阻塞模式的操作。</p><p>支持多任务对同一个队列进行读写。</p><p>可用于任务间的异步通信。</p><h3 id="3-消息队列的组成"><a href="#3-消息队列的组成" class="headerlink" title="3.消息队列的组成"></a>3.消息队列的组成</h3><p><strong>消息池</strong>：存储消息的内存区域，通常是固定大小。</p><p><strong>消息头和尾指针</strong>：指示当前消息队列的写入和读取位置。</p><p><strong>状态变量</strong>：包括当前队列中的消息数、最大容量等。</p><p><strong>任务等待列表</strong>：记录阻塞在消息队列上的任务。</p><h2 id="三、消息队列的工作机制"><a href="#三、消息队列的工作机制" class="headerlink" title="三、消息队列的工作机制"></a>三、消息队列的工作机制</h2><p><img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/ipc2/figures/07msg_work.png" alt="消息队列工作示意图"></p><p>消息队列里面都有一个内存池，这个内存池会按照一定的大小划分为多个消息框，消息队列的消息就保存在这个消息框中，而这个消息框是以链表的形式组织起来的</p><p>这里面有空闲链表的这个指针，它指向消息队列中的空闲的消息框（就是没有存放消息的消息框），消息队列还有一个链表头，一个链表尾。链表头指向目前系统中消息队列的第一条可用的消息。这个等待线程队列就是从消息队列链表头中获取消息。链表尾指向消息队列中最后一条可用消息。</p><p>当线程或者中断服务程序往消息队列中发送消息的时候，系统会从这个空闲链表中，取到一个空闲的消息框然后将发送过来的消息存入空闲的消息框中，然后将这个空闲的消息框连接到消息队列的尾部，消息队列也支持紧急消息的发送，当线程或者中断服务程序发送的是一条紧急消息的时候，那么系统会直接将消息框连接到消息队列的头部，这样等待线程队列就可以第一时间获取这个消息并进行处理。</p><p>当消息队列满的时候（也就是消息框都存有消息的时候），如果这个时候线程或者中断服务程序还往消息队列发送消息，那么就会发送失败。</p><p>当等待线程队列在读取消息的时候，如果有消息，那就读取消息并处理。如果消息队列是空的，那么他们要么就直接返回失败，要么就会按照一定的超时时间挂起等待。</p><h2 id="四、消息队列的管理方式"><a href="#四、消息队列的管理方式" class="headerlink" title="四、消息队列的管理方式"></a>四、消息队列的管理方式</h2><h3 id="RT-thread中的消息队列控制块"><a href="#RT-thread中的消息队列控制块" class="headerlink" title="RT-thread中的消息队列控制块"></a>RT-thread中的消息队列控制块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_messagequeue</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* msg_pool;                     <span class="comment">/* 指向存放消息的缓冲区的指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">rt_uint16_t</span> msg_size;               <span class="comment">/* 每个消息的长度 */</span></span><br><span class="line">    <span class="type">rt_uint16_t</span> max_msgs;               <span class="comment">/* 最大能够容纳的消息数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">rt_uint16_t</span> entry;                  <span class="comment">/* 队列中已有的消息数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* msg_queue_head;               <span class="comment">/* 消息链表头 */</span></span><br><span class="line">    <span class="type">void</span>* msg_queue_tail;               <span class="comment">/* 消息链表尾 */</span></span><br><span class="line">    <span class="type">void</span>* msg_queue_free;               <span class="comment">/* 空闲消息链表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">rt_list_t</span> suspend_sender_thread;    <span class="comment">/* 发送线程的挂起等待队列 */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_messagequeue</span>* <span class="title">rt_mq_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>在 RT-Thread 中，消息队列控制块是操作系统用于管理消息队列的一个数据结构，其中含有消息队列相关的重要参数，在消息队列的功能实现中起重要的作用。消息队列的相关接口如下图所示，对一个消息队列的操作包含：创建消息队列 - 发送消息 - 接收消息 - 删除消息队列。</p><p><img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/ipc2/figures/07msg_ops.png" alt="消息队列相关接口"></p><h2 id="五、消息队列的操作"><a href="#五、消息队列的操作" class="headerlink" title="五、消息队列的操作"></a>五、消息队列的操作</h2><h3 id="1-消息队列的创建"><a href="#1-消息队列的创建" class="headerlink" title="1.消息队列的创建"></a>1.消息队列的创建</h3><p>使用 <code>rt_mq_create</code> 或静态消息队列结构初始化消息队列。</p><p>参数包括队列的名称、消息大小、最大消息数以及分配的内存池。</p><p><strong>动态：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_mq_t</span> <span class="title function_">rt_mq_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">rt_size_t</span> msg_size,</span></span><br><span class="line"><span class="params">            <span class="type">rt_size_t</span> max_msgs, <span class="type">rt_uint8_t</span> flag)</span>;</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>消息队列的名称</td></tr><tr><td>msg_size</td><td>消息队列中一条消息的最大长度，单位字节</td></tr><tr><td>max_msgs</td><td>消息队列的最大个数</td></tr><tr><td>flag</td><td>消息队列采用的等待方式，它可以取如下数值： RT_IPC_FLAG_FIFO 或 RT_IPC_FLAG_PRIO</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>发送成功</td></tr><tr><td>消息队列对象的句柄</td><td>成功</td></tr><tr><td>RT_NULL</td><td>失败</td></tr></tbody></table><p><strong>静态：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_init</span><span class="params">(<span class="type">rt_mq_t</span> mq, <span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> *msgpool, <span class="type">rt_size_t</span> msg_size,</span></span><br><span class="line"><span class="params">                        <span class="type">rt_size_t</span> pool_size, <span class="type">rt_uint8_t</span> flag)</span>;</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>rt_mq_create</code> 创建的消息队列无需额外初始化。</p><p>如果使用 <code>rt_mq_init</code>（静态方式），需要手动提供消息存储区域并进行初始化。</p><p>创建后，无论动态还是静态方式，消息队列即可直接使用。</p><p>示例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_mq_t</span> mq;</span><br><span class="line">mq = rt_mq_create(<span class="string">"my_mq"</span>, <span class="number">32</span>, <span class="number">16</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"><span class="keyword">if</span> (mq != RT_NULL)</span><br><span class="line">{</span><br><span class="line">    rt_kprintf(<span class="string">"Message queue created successfully\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="2-消息发送"><a href="#2-消息发送" class="headerlink" title="2.消息发送"></a>2.消息发送</h3><p>使用 <code>rt_mq_send</code> 将数据放入消息队列。</p><p>当发送消息时，消息队列对象先从空闲消息链表上取下一个空闲消息块，把线程或者中断服务程序发送的消息内容复制到消息块上，然后把该消息块挂到消息队列的尾部。</p><p>当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消息队列已满，此时，发送消息的的线程或者中断程序会收到一个错误码（-RT_EFULL）。</p><p><strong>一般消息</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_send</span> <span class="params">(<span class="type">rt_mq_t</span> mq, <span class="type">void</span>* buffer, <span class="type">rt_size_t</span> size)</span>;</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>成功</td></tr><tr><td>-RT_EFULL</td><td>消息队列已满</td></tr><tr><td>-RT_ERROR</td><td>失败，表示发送的消息长度大于消息队列中消息的最大长度</td></tr></tbody></table><p><strong>紧急消息</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_urgent</span><span class="params">(<span class="type">rt_mq_t</span> mq, <span class="type">void</span>* buffer, <span class="type">rt_size_t</span> size)</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="3-消息接收"><a href="#3-消息接收" class="headerlink" title="3.消息接收"></a>3.消息接收</h3><p>当消息队列中有消息时，接收者才能接收消息，否则接收者会根据超时时间设置，或挂起在消息队列的等待线程队列上，或直接返回。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_ssize_t</span> <span class="title function_">rt_mq_recv</span> <span class="params">(<span class="type">rt_mq_t</span> mq, <span class="type">void</span>* buffer,</span></span><br><span class="line"><span class="params">                    <span class="type">rt_size_t</span> size, <span class="type">rt_int32_t</span> timeout)</span>;</span><br></pre></td></tr></tbody></table></figure><p>接收消息时，接收者需指定存储消息的消息队列对象句柄，并且指定一个内存缓冲区，接收到的消息内容将被复制到该缓冲区里。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>mq</td><td>消息队列对象的句柄</td></tr><tr><td>buffer</td><td>消息内容</td></tr><tr><td>size</td><td>消息大小</td></tr><tr><td>timeout</td><td>指定的超时时间</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>接收到消息的长度</td><td>成功收到</td></tr><tr><td>-RT_ETIMEOUT</td><td>超时</td></tr><tr><td>-RT_ERROR</td><td>失败，返回错误</td></tr></tbody></table><h3 id="4-消息队列的删除"><a href="#4-消息队列的删除" class="headerlink" title="4.消息队列的删除"></a>4.消息队列的删除</h3><p>当消息队列不再被使用时，应该删除它以释放系统资源，一旦操作完成，消息队列将被永久性地删除。删除消息队列时，如果有线程被挂起在该消息队列等待队列上，则内核先唤醒挂起在该消息等待队列上的所有线程（线程返回值是 - RT_ERROR），然后再释放消息队列使用的内存，最后删除消息队列对象。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_delete</span><span class="params">(<span class="type">rt_mq_t</span> mq)</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="六、消息队列的使用场景"><a href="#六、消息队列的使用场景" class="headerlink" title="六、消息队列的使用场景"></a>六、消息队列的使用场景</h2><ol><li><p><strong>任务间通信：</strong></p><p>用于任务之间的数据传递。</p></li><li><p><strong>中断与任务通信：</strong></p><p>中断服务程序将采集的数据发送到任务进行处理。</p></li></ol><h2 id="七、消息队列和邮箱的区别"><a href="#七、消息队列和邮箱的区别" class="headerlink" title="七、消息队列和邮箱的区别"></a>七、消息队列和邮箱的区别</h2><table><thead><tr><th><strong>特性</strong></th><th><strong>消息队列</strong></th><th><strong>邮箱</strong></th></tr></thead><tbody><tr><td><strong>数据存储</strong></td><td>消息内容存储在队列中</td><td>仅存储消息地址，不存储消息内容</td></tr><tr><td><strong>消息大小</strong></td><td>用户定义，每条消息大小相同</td><td>固定长度，通常为指针大小（32/64 位）</td></tr><tr><td><strong>容量</strong></td><td>可存储多条消息，受缓冲区大小限制</td><td>存储的消息数量固定，由初始化时的容量决定</td></tr><tr><td><strong>适用场景</strong></td><td>复杂数据或需要消息排队的场景</td><td>只传递指针或轻量级消息，无需复制数据</td></tr><tr><td><strong>内存开销</strong></td><td>较高，需分配缓冲区</td><td>较低，只需存储消息地址</td></tr><tr><td><strong>性能</strong></td><td>较低，数据需要复制</td><td>较高，仅传递指针</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RT-threadq嵌入式实时操作系统&lt;/p&gt;
&lt;p&gt;物联网操作系统是指以操作系统内核（可以是 RTOS、Linux 等）为基础，包括如文件系统、图形库等较为完整的中间件组件，具备低功耗、安全、通信协议支持和云端连接能力的软件平台&lt;/p&gt;
&lt;h1 id=&quot;邮箱&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MQTT协议学习报告</title>
    <link href="https://whj.github.io/2024/12/02/MQTT%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>https://whj.github.io/2024/12/02/MQTT%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</id>
    <published>2024-12-02T08:28:30.389Z</published>
    <updated>2024-12-02T08:50:52.304Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-协议概述"><a href="#1-协议概述" class="headerlink" title="1. 协议概述"></a><strong>1. 协议概述</strong></h3><h4 id="1-1-MQTT-的定义与背景"><a href="#1-1-MQTT-的定义与背景" class="headerlink" title="1.1 MQTT 的定义与背景"></a><strong>1.1 MQTT 的定义与背景</strong></h4><p>​MQTT（Message Queuing Telemetry Transport）是基于 TCP/IP 的轻量级消息协议，采用<strong>发布/订阅</strong>模式进行数据传输，适合资源受限设备或低带宽、高延迟的网络环境。</p><ul><li><p><strong>优势：</strong></p><p><strong>轻量级</strong>：协议报文小，节省流量。</p><p><strong>发布/订阅模式</strong>：解耦消息发送方与接收方。</p><p><strong>QoS 保障</strong>：提供三种质量等级，满足不同可靠性需求。</p><p><strong>保活机制</strong>：通过心跳维持长连接。</p><p><strong>支持遗嘱消息</strong>：在客户端异常断开时向订阅方通知信息。</p></li></ul><h4 id="1-2-典型应用场景"><a href="#1-2-典型应用场景" class="headerlink" title="1.2 典型应用场景"></a><strong>1.2 典型应用场景</strong></h4><p><strong>远程监控：</strong>如智能家居、环境监测。</p><p><strong>消息推送：</strong>如即时通讯、在线报警。</p><p><strong>设备互联：</strong>如车联网、工业控制。</p><hr><h3 id="2-MQTT-协议特点"><a href="#2-MQTT-协议特点" class="headerlink" title="2. MQTT 协议特点"></a><strong>2. MQTT 协议特点</strong></h3><h4 id="2-1-发布-订阅模式"><a href="#2-1-发布-订阅模式" class="headerlink" title="2.1 发布/订阅模式"></a><strong>2.1 发布/订阅模式</strong></h4><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241108141138905.png" alt="image-20241108141138905"></p><ul><li><p><strong>模型结构</strong>：</p><ol><li><strong>发布者</strong>：向 Broker 指定的主题（Topic）发送消息。</li><li><strong>Broker（代理服务器）</strong>：负责消息路由，将消息分发给订阅该主题的客户端。</li><li><strong>订阅者</strong>：通过订阅主题接收消息。</li></ol><p>MQTT协议支持一对多,多对多的应用场景,所以发布者也可以是订阅者。</p></li><li><p><strong>对比传统点对点通信</strong>：</p><ul><li>发布者与订阅者解耦，降低耦合度，提升扩展性。</li><li>支持多对多通信。</li></ul></li></ul><h4 id="2-2-主题与通配符"><a href="#2-2-主题与通配符" class="headerlink" title="2.2 主题与通配符"></a><strong>2.2 主题与通配符</strong></h4><p>主题是 MQTT 消息传递的核心。支持层级结构和通配符：</p><ul><li><p><strong>层级结构</strong>：如 <code>home/sensor/temperature</code> 表示家庭中传感器的温度数据。</p><p>topic是一个UTF-8字符串，是发布/订阅消息的传输中介，可以向topic发布或订阅消息</p></li><li><p><strong>通配符：</strong></p><p><code>+</code>：匹配单层，如 <code>home/+/temperature</code>。</p><p><code>#</code>：匹配多层，如 <code>home/#</code>。</p></li></ul><h4 id="2-3-消息可靠性（QoS）"><a href="#2-3-消息可靠性（QoS）" class="headerlink" title="2.3 消息可靠性（QoS）"></a><strong>2.3 消息可靠性（QoS）</strong></h4><p>MQTT 提供三种服务质量等级，适配不同的可靠性需求：</p><ul><li><strong>QoS 0（最多一次）</strong>：消息发送后不确认，可能丢失。</li><li><strong>QoS 1（至少一次）</strong>：消息至少到达一次，可能重复。</li><li><strong>QoS 2（仅一次）</strong>：消息只到达一次，通过四步握手保证可靠性。</li></ul><h4 id="2-4-保活机制"><a href="#2-4-保活机制" class="headerlink" title="2.4 保活机制"></a><strong>2.4 保活机制</strong></h4><ul><li>客户端通过 <code>PINGREQ</code> 和 <code>PINGRESP</code> 报文维持连接。</li><li>心跳间隔由 <code>keepAliveInterval</code> 参数控制，单位为秒。</li></ul><h4 id="2-5-遗嘱消息"><a href="#2-5-遗嘱消息" class="headerlink" title="2.5 遗嘱消息"></a><strong>2.5 遗嘱消息</strong></h4><p>客户端异常断开时，Broker 会自动发布事先设置的遗嘱消息，通知订阅者设备的状态变化。</p><hr><h3 id="3-MQTT-报文与通信流程"><a href="#3-MQTT-报文与通信流程" class="headerlink" title="3. MQTT 报文与通信流程"></a><strong>3. MQTT 报文与通信流程</strong></h3><h4 id="3-1-MQTT-报文结构"><a href="#3-1-MQTT-报文结构" class="headerlink" title="3.1 MQTT 报文结构"></a><strong>3.1 MQTT 报文结构</strong></h4><p>MQTT 的消息由三部分组成：</p><ol><li><p><strong>固定报头</strong>：包含报文类型、标志和剩余长度。</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241108142325603.png" alt="image-20241108142325603"></p></li><li><p><strong>可变报头</strong>：如主题名、消息 ID 等（部分报文使用）。</p></li><li><p><strong>有效载荷</strong>：具体传输的数据。</p></li></ol><h4 id="3-2-报文类型"><a href="#3-2-报文类型" class="headerlink" title="3.2 报文类型"></a><strong>3.2 报文类型</strong></h4><p>常见报文类型及作用：</p><table><thead><tr><th align="left">报文类型</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">CONNECT</td><td align="left">客户端请求连接 Broker</td></tr><tr><td align="left">CONNACK</td><td align="left">Broker 响应连接请求</td></tr><tr><td align="left">PUBLISH</td><td align="left">发布消息</td></tr><tr><td align="left">PUBACK</td><td align="left">QoS 1 发布确认</td></tr><tr><td align="left">PUBREC</td><td align="left">QoS 2 发布接收（第一步）</td></tr><tr><td align="left">PUBREL</td><td align="left">QoS 2 发布释放（第二步）</td></tr><tr><td align="left">PUBCOMP</td><td align="left">QoS 2 发布完成（第三步）</td></tr><tr><td align="left">SUBSCRIBE</td><td align="left">订阅主题</td></tr><tr><td align="left">SUBACK</td><td align="left">确认订阅</td></tr><tr><td align="left">UNSUBSCRIBE</td><td align="left">取消订阅</td></tr><tr><td align="left">UNSUBACK</td><td align="left">确认取消订阅</td></tr><tr><td align="left">PINGREQ</td><td align="left">客户端发送心跳请求</td></tr><tr><td align="left">PINGRESP</td><td align="left">Broker 响应心跳请求</td></tr><tr><td align="left">DISCONNECT</td><td align="left">客户端主动断开连接</td></tr></tbody></table><h4 id="3-3-通信流程示例"><a href="#3-3-通信流程示例" class="headerlink" title="3.3 通信流程示例"></a><strong>3.3 通信流程示例</strong></h4><ol><li><p>连接建立：</p><p>客户端发送 <code>CONNECT</code> 请求。</p><p>Broker 返回 <code>CONNACK</code>，连接成功。</p></li><li><p>发布消息：</p><p>客户端通过 <code>PUBLISH</code> 向主题发送消息。</p><p>根据 QoS 等级进行不同的确认过程。</p></li><li><p>订阅主题：</p><p>客户端发送 <code>SUBSCRIBE</code> 报文。</p><p>Broker 返回 <code>SUBACK</code> 确认订阅。</p></li><li><p>断开连接：</p><p>客户端主动发送 <code>DISCONNECT</code>。</p><p>Broker 释放相关资源。</p></li></ol><hr><h3 id="4-优化与安全性"><a href="#4-优化与安全性" class="headerlink" title="4. 优化与安全性"></a><strong>4. 优化与安全性</strong></h3><h4 id="4-1-性能优化"><a href="#4-1-性能优化" class="headerlink" title="4.1 性能优化"></a><strong>4.1 性能优化</strong></h4><ol><li><p>合理配置 QoS：</p><p>QoS 0：适合不敏感的传感器数据。</p><p>QoS 1：适合日志或状态更新。</p><p>QoS 2：适合控制指令等关键数据。</p></li><li><p>批量传输：</p><p>减少频繁的单条消息发布，降低网络开销。</p></li><li><p>主题设计：</p><p>设计层级清晰的主题，减少通配符滥用。</p></li></ol><h4 id="4-2-安全机制"><a href="#4-2-安全机制" class="headerlink" title="4.2 安全机制"></a><strong>4.2 安全机制</strong></h4><ol><li><p>认证：</p><p>使用用户名和密码验证客户端身份。</p></li><li><p>加密：</p><p>使用 TLS/SSL 确保数据传输的安全性。</p><p>使用加密端口。</p></li><li><p>异常处理：</p><p>配置遗嘱消息，检测客户端异常断开。</p><p>配置重连机制，确保连接稳定。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-协议概述&quot;&gt;&lt;a href=&quot;#1-协议概述&quot; class=&quot;headerlink&quot; title=&quot;1. 协议概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 协议概述&lt;/strong&gt;&lt;/h3&gt;&lt;h4 id=&quot;1-1-MQTT-的定义与背景&quot;&gt;&lt;a href=&quot;#1-1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VScode远程映射配置指南</title>
    <link href="https://whj.github.io/2024/12/02/VScode%E9%85%8D%E7%BD%AE/"/>
    <id>https://whj.github.io/2024/12/02/VScode%E9%85%8D%E7%BD%AE/</id>
    <published>2024-12-02T08:28:30.381Z</published>
    <updated>2024-12-02T08:52:11.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VScode-映射的搭建手册"><a href="#VScode-映射的搭建手册" class="headerlink" title="VScode 映射的搭建手册"></a>VScode 映射的搭建手册</h1><h2 id="一、插件的安装"><a href="#一、插件的安装" class="headerlink" title="一、插件的安装"></a>一、插件的安装</h2><p>下载安装SSH插件</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201160519792.png" alt="image-20241201160519792"></p><p>可以发现左边工具栏多了一个窗口</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201160612997.png" alt="image-20241201160612997"></p><p>然后点击左下角绿色箭头，会提示连接到主机</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201160653897.png" alt="image-20241201160653897"></p><p>点击后会显示配置主机地址</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201160730563.png" alt="image-20241201160730563"></p><p>按照提示输出ssh 用户名和地址</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201161138622.png" alt="image-20241201161138622"></p><p>修改配置文件</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201162504814.png" alt="image-20241201162504814"></p><h2 id="二、VScode-server的离线安装"><a href="#二、VScode-server的离线安装" class="headerlink" title="二、VScode server的离线安装"></a>二、VScode server的离线安装</h2><h3 id="1-获取压缩包"><a href="#1-获取压缩包" class="headerlink" title="1.获取压缩包"></a>1.获取压缩包</h3><p>后面需要安装VScode server，因为云桌面不能连网，所以这个需要在本地电脑下载，然后传入云桌面。具体操作流程如下：</p><p>在以上所有步骤完成后，连接时会提示正在下载VScode server，但是会下载失败，然后在终端会提示server的download URL，复制这个URL到本地电脑获取，以我的URL为例：</p><p>[<a href="https://update.code.visualstudio.com/commit:384ff7382de624fb94dbaf6da11977bba1ecd427/cli-alpine-x64/stable">https://update.code.visualstudio.com/commit:384ff7382de624fb94dbaf6da11977bba1ecd427/cli-alpine-x64/stable</a> ]</p><p>复制到浏览器后会获取一个vscode_cli_alpine_x64_cli.tar.gz的压缩包，将其传入云桌面 </p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201183823190.png" alt="image-20241201183823190"></p><p>然后再将URL的后缀修改一下，下载linux的压缩包，如：</p><p>[<a href="https://update.code.visualstudio.com/commit:384ff7382de624fb94dbaf6da11977bba1ecd427/server-linux-x64/stable">https://update.code.visualstudio.com/commit:384ff7382de624fb94dbaf6da11977bba1ecd427/server-linux-x64/stable</a> ]</p><p>获取到vscode-server-linux-x64.tar.gz压缩包后，同样将其传入云桌面。</p><h3 id="2-解压文件并调整目录结构"><a href="#2-解压文件并调整目录结构" class="headerlink" title="2.解压文件并调整目录结构"></a>2.解压文件并调整目录结构</h3><h4 id="2-1-vscode-cli-alpine-x64-cli-tar-gz的处理方式"><a href="#2-1-vscode-cli-alpine-x64-cli-tar-gz的处理方式" class="headerlink" title="2.1 vscode_cli_alpine_x64_cli.tar.gz的处理方式"></a>2.1 vscode_cli_alpine_x64_cli.tar.gz的处理方式</h4><p>打开自己映射盘的工作目录</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201184506399.png" alt="image-20241201184506399"></p><p>打开.vscode-server</p><p>在里面新建一个bin目录和一个cli目录</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201184605730.png" alt="image-20241201184605730"></p><p><strong>然后将刚刚的两个压缩包复制到bin目录下解压。ps：需要解压两次</strong></p><p>解压这个压缩包vscode_cli_alpine_x64_cli.tar.gz后，会获得一个名为Code的文件，我们需要将其改名，并移动到和bin,cli同级的目录下</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201184843330.png" alt="image-20241201184843330"></p><p>改名规则为<strong>code-[你的commit ID]</strong>,commit ID可以在帮助-关于处查看，上面下载压缩包时也需要用到commit ID。</p><h4 id="2-2-vscode-server-linux-x64-tar-gz的处理方式"><a href="#2-2-vscode-server-linux-x64-tar-gz的处理方式" class="headerlink" title="2.2 vscode-server-linux-x64.tar.gz的处理方式"></a>2.2 vscode-server-linux-x64.tar.gz的处理方式</h4><p>在bin目录下解压vscode-server-linux-x64.tar.gz后，会得到一个文件夹vscode-server-linux-x64</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201185148495.png" alt="image-20241201185148495"></p><p>接着我们回到cli目录，新建一个名为servers的目录</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201185322579.png" alt="image-20241201185322579"></p><p>再到servers目录里面，新建一个**Stable-[你的commit ID]**的目录</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201185416423.png" alt="image-20241201185416423"></p><p>然后将vscode-server-linux-x64改名为<strong>server</strong>，移动到**cli/servers/Stable-[commit ID]**目录下</p><p>然后在处<strong>cli</strong>目录下手动创建一个iru.json文件，将文件内容填充为**[“Stable-你的commit ID”]**</p><h2 id="三、连接到服务器"><a href="#三、连接到服务器" class="headerlink" title="三、连接到服务器"></a>三、连接到服务器</h2><p>上面的步骤完成后，打开vscode尝试建立连接，操作步骤参考<strong>一、插件的安装</strong></p><p>如果此时还失败，可以尝试把SSH的自动下载功能关闭：</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201190204376.png" alt="image-20241201190204376"></p><p>打开 Remote-SSH的设置，找到Local Server Download，选择off:</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201190303206.png" alt="image-20241201190303206"></p><p>然后重启vscode重新连接</p><p><img src="https://raw.githubusercontent.com/wwwhhhjj/Typora-picture/main/%E5%9B%BE%E5%BA%8Aimage-20241201190355028.png" alt="image-20241201190355028"></p><p>建立映射成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VScode-映射的搭建手册&quot;&gt;&lt;a href=&quot;#VScode-映射的搭建手册&quot; class=&quot;headerlink&quot; title=&quot;VScode 映射的搭建手册&quot;&gt;&lt;/a&gt;VScode 映射的搭建手册&lt;/h1&gt;&lt;h2 id=&quot;一、插件的安装&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://whj.github.io/2024/06/05/hello-world/"/>
    <id>https://whj.github.io/2024/06/05/hello-world/</id>
    <published>2024-06-04T16:17:20.835Z</published>
    <updated>2024-12-02T08:28:35.588Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
